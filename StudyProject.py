# -*- coding: utf-8 -*-
"""PranitBhansali_StudyProject_DNABubbles.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/156aojCXVzGlt4lZeu564XgMDPifzpeIv
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, Dict, Optional

class SimulationConstants:

    EV_TO_J = 1.60219e-19  # 1 eV = 1.60219 × 10^−19 J
    ANGSTROM_TO_M = 1e-10  # 1 Å = 10^−10 m
    INV_ANGSTROM_TO_INV_M = 1e10  # 1 Å^-1 = 10^10 m^-1
    ANGSTROM2_TO_M2 = 1e-20  # 1 Å^2 = 10^−20 m^2
    BOLTZMANN = 1.380649e-23  # J/K

class DNAStrand:

    def __init__(
        self,
        sequence: str,
        name: Optional[str] = None,
        custom_params: Optional[Dict] = None
    ):

        self.sequence = sequence
        self.name = name or sequence
        self.length = len(sequence)

        # Default parameters with option to override
        self.params = {
            # Physical parameters
            'k': 0.025 * (SimulationConstants.EV_TO_J / SimulationConstants.ANGSTROM2_TO_M2),
            'rho': 2,
            'beta': 0.35 * SimulationConstants.INV_ANGSTROM_TO_INV_M,
            'aGC': 6.9 * SimulationConstants.INV_ANGSTROM_TO_INV_M,
            'aAT': 4.2 * SimulationConstants.INV_ANGSTROM_TO_INV_M,
            'DGC': 0.075 * SimulationConstants.EV_TO_J,
            'DAT': 0.05 * SimulationConstants.EV_TO_J,

            # Simulation control
            'threshold': 0.5 * 1e-10,
            'num_steps': 500000,
            'step_size_ma': 1.9e-10,
            'num_sim': 2
        }

        # Update with custom parameters if provided
        if custom_params:
            self.params.update(custom_params)

    def calculate_potential(self, y: np.ndarray) -> float:

        V = 0

        for n in range(self.length):
            # Determine base pair specific parameters
            D = self.params['DAT'] if self.sequence[n] in ['A', 'T'] else self.params['DGC']
            a = self.params['aAT'] if self.sequence[n] in ['A', 'T'] else self.params['aGC']

            # Morse potential for individual base pairs
            V += D * (np.exp(-a * y[n]) - 1)**2

            # Coupling potential between adjacent base pairs
            if n > 0:
                V += (self.params['k'] / 2) * (
                    1 + self.params['rho'] * np.exp(-self.params['beta'] * (y[n] + y[n-1]))
                ) * (y[n] - y[n-1])**2

        return V

    def metropolis_algorithm(
        self,
        T: float
    ) -> Tuple[np.ndarray, float]:

        y = np.zeros(self.length)
        accept_count = 0

        for _ in range(self.params['num_steps']):
            # Randomly select a base pair to modify
            n = np.random.randint(self.length)

            # Create a trial move
            y_new = y.copy()
            y_new[n] += np.random.normal() * self.params['step_size_ma']

            # Calculate energies
            E_old = self.calculate_potential(y)
            E_new = self.calculate_potential(y_new)

            # Acceptance criteria
            if E_new < E_old or np.random.random() < np.exp(
                -(E_new - E_old) / (T * SimulationConstants.BOLTZMANN)
            ):
                y = y_new
                accept_count += 1

        return y, accept_count / self.params['num_steps']

    def perform_temperature_sweep(
        self,
        T_range: Tuple[float, float],
        num_T: int
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:

        temperature = np.linspace(T_range[0], T_range[1], num_T)

        # Results storage
        f_values = np.zeros(num_T)
        f_values_std = np.zeros(num_T)
        acceptance_rates = np.zeros(num_T)

        # Simulation loop
        for t_idx, T in enumerate(temperature):
            # Initialize arrays to collect simulation results
            sim_displacements = []
            sim_accept_rates = []

            # Run multiple simulations at each temperature
            for _ in range(self.params['num_sim']):
                y, accept_rate = self.metropolis_algorithm(T)
                sim_displacements.append(y)
                sim_accept_rates.append(accept_rate)

            # Convert simulation results to NumPy arrays
            sim_displacements = np.array(sim_displacements)
            sim_accept_rates = np.array(sim_accept_rates)

            # Calculate fractions above threshold
            sim_f_values = np.mean(sim_displacements > self.params['threshold'], axis=1)

            # Store results for this temperature
            f_values[t_idx] = np.mean(sim_f_values)
            f_values_std[t_idx] = np.std(sim_f_values)
            acceptance_rates[t_idx] = np.mean(sim_accept_rates)

        return temperature, f_values, f_values_std, acceptance_rates

    def plot_melting_profile(
        self,
        temperature: np.ndarray,
        f_values: np.ndarray,
        f_values_std: np.ndarray,
        ax: Optional[plt.Axes] = None
    ):

        # Use provided axes or create a new figure
        if ax is None:
            fig, ax = plt.subplots(figsize=(10, 6))

        ax.errorbar(
            temperature, f_values, yerr=f_values_std,
            fmt='o-', markeredgecolor='k', markerfacecolor='none',
            linewidth=1.5, label=self.name
        )
        ax.set_xlabel('T (K)', fontsize=14)
        ax.set_ylabel('Fraction', fontsize=14)
        ax.set_xlim(temperature[0], temperature[-1])
        ax.set_ylim(0, 1)
        ax.set_title(f'Melting Profiles', fontsize=14)
        ax.grid(True)
        ax.legend()

        # Annotation with simulation details
        details_text = '\n'.join([
            f'Simulations: {self.params["num_sim"]}',
            f'Threshold: {self.params["threshold"]:.1e}',
            f'Step Size: {self.params["step_size_ma"]:.1e}'
        ])
        ax.text(
            temperature[0] + 5, 0.85, details_text,
            fontsize=10,
            bbox=dict(boxstyle='round', facecolor='white', edgecolor='black', alpha=0.7)
        )

def main():
    # Create multiple DNA strand objects
    strands = [DNAStrand('CCGCCAGCGGCCTTTACTAAAGGCCGCTGCGCC', name='L33B9')]

    # Temperature sweep parameters
    T_range = (300, 400)
    num_T = 50

    # Create a figure to plot multiple strands
    fig, ax = plt.subplots(figsize=(12, 8))

    # Perform simulation and plot for each strand
    for strand in strands:
        # Perform temperature sweep
        temperature, f_values, f_values_std, acceptance_rates = strand.perform_temperature_sweep(
            T_range, num_T
        )

        # Print average acceptance rate
        print(f'{strand.name} - Average Acceptance Rate: {np.mean(acceptance_rates):.6f}')

        # Plot melting profile
        strand.plot_melting_profile(temperature, f_values, f_values_std, ax)

    plt.tight_layout()
    plt.show()

if __name__ == '__main__':
    main()